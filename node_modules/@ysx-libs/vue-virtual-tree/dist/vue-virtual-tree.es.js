var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { pushScopeId, popScopeId, nextTick, openBlock, createBlock, withScopeId, markRaw, shallowReactive, resolveComponent, resolveDirective, withDirectives, renderSlot, createCommentVNode, createVNode, Fragment, renderList, toRaw, defineComponent, computed, createElementBlock, normalizeClass, unref, createElementVNode, toRefs, inject, normalizeStyle, withCtx, ref, watch, watchEffect, useSlots, provide } from "vue";
var index = "";
function getInternetExplorerVersion() {
  var ua = window.navigator.userAgent;
  var msie = ua.indexOf("MSIE ");
  if (msie > 0) {
    return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
  }
  var trident = ua.indexOf("Trident/");
  if (trident > 0) {
    var rv = ua.indexOf("rv:");
    return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
  }
  var edge = ua.indexOf("Edge/");
  if (edge > 0) {
    return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
  }
  return -1;
}
let isIE;
function initCompat() {
  if (!initCompat.init) {
    initCompat.init = true;
    isIE = getInternetExplorerVersion() !== -1;
  }
}
var script = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    initCompat();
    nextTick(() => {
      this._w = this.$el.offsetWidth;
      this._h = this.$el.offsetHeight;
      if (this.emitOnMount) {
        this.emitSize();
      }
    });
    const object = document.createElement("object");
    this._resizeObject = object;
    object.setAttribute("aria-hidden", "true");
    object.setAttribute("tabindex", -1);
    object.onload = this.addResizeHandlers;
    object.type = "text/html";
    if (isIE) {
      this.$el.appendChild(object);
    }
    object.data = "about:blank";
    if (!isIE) {
      this.$el.appendChild(object);
    }
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
        this._w = this.$el.offsetWidth;
        this._h = this.$el.offsetHeight;
        this.emitSize();
      }
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
      this.compareAndNotify();
    },
    removeResizeHandlers() {
      if (this._resizeObject && this._resizeObject.onload) {
        if (!isIE && this._resizeObject.contentDocument) {
          this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
        }
        this.$el.removeChild(this._resizeObject);
        this._resizeObject.onload = null;
        this._resizeObject = null;
      }
    }
  }
};
const _withId = /* @__PURE__ */ withScopeId("data-v-b329ee4c");
pushScopeId("data-v-b329ee4c");
const _hoisted_1$3 = {
  class: "resize-observer",
  tabindex: "-1"
};
popScopeId();
const render = /* @__PURE__ */ _withId((_ctx, _cache, $props, $setup, $data, $options) => {
  return openBlock(), createBlock("div", _hoisted_1$3);
});
script.render = render;
script.__scopeId = "data-v-b329ee4c";
script.__file = "src/components/ResizeObserver.vue";
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props2) {
  for (var i = 0; i < props2.length; i++) {
    var descriptor = props2[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function processOptions(value) {
  var options;
  if (typeof value === "function") {
    options = {
      callback: value
    };
  } else {
    options = value;
  }
  return options;
}
function throttle(callback, delay) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var timeout;
  var lastState;
  var currentArgs;
  var throttled = function throttled2(state) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    currentArgs = args;
    if (timeout && state === lastState)
      return;
    var leading = options.leading;
    if (typeof leading === "function") {
      leading = leading(state, lastState);
    }
    if ((!timeout || state !== lastState) && leading) {
      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));
    }
    lastState = state;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));
      timeout = 0;
    }, delay);
  };
  throttled._clear = function() {
    clearTimeout(timeout);
    timeout = null;
  };
  return throttled;
}
function deepEqual(val1, val2) {
  if (val1 === val2)
    return true;
  if (_typeof$1(val1) === "object") {
    for (var key in val1) {
      if (!deepEqual(val1[key], val2[key])) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var VisibilityState = /* @__PURE__ */ function() {
  function VisibilityState2(el, options, vnode) {
    _classCallCheck(this, VisibilityState2);
    this.el = el;
    this.observer = null;
    this.frozen = false;
    this.createObserver(options, vnode);
  }
  _createClass(VisibilityState2, [{
    key: "createObserver",
    value: function createObserver(options, vnode) {
      var _this = this;
      if (this.observer) {
        this.destroyObserver();
      }
      if (this.frozen)
        return;
      this.options = processOptions(options);
      this.callback = function(result, entry) {
        _this.options.callback(result, entry);
        if (result && _this.options.once) {
          _this.frozen = true;
          _this.destroyObserver();
        }
      };
      if (this.callback && this.options.throttle) {
        var _ref = this.options.throttleOptions || {}, _leading = _ref.leading;
        this.callback = throttle(this.callback, this.options.throttle, {
          leading: function leading(state) {
            return _leading === "both" || _leading === "visible" && state || _leading === "hidden" && !state;
          }
        });
      }
      this.oldResult = void 0;
      this.observer = new IntersectionObserver(function(entries) {
        var entry = entries[0];
        if (entries.length > 1) {
          var intersectingEntry = entries.find(function(e) {
            return e.isIntersecting;
          });
          if (intersectingEntry) {
            entry = intersectingEntry;
          }
        }
        if (_this.callback) {
          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;
          if (result === _this.oldResult)
            return;
          _this.oldResult = result;
          _this.callback(result, entry);
        }
      }, this.options.intersection);
      nextTick(function() {
        if (_this.observer) {
          _this.observer.observe(_this.el);
        }
      });
    }
  }, {
    key: "destroyObserver",
    value: function destroyObserver() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }
      if (this.callback && this.callback._clear) {
        this.callback._clear();
        this.callback = null;
      }
    }
  }, {
    key: "threshold",
    get: function get() {
      return this.options.intersection && typeof this.options.intersection.threshold === "number" ? this.options.intersection.threshold : 0;
    }
  }]);
  return VisibilityState2;
}();
function beforeMount(el, _ref2, vnode) {
  var value = _ref2.value;
  if (!value)
    return;
  if (typeof IntersectionObserver === "undefined") {
    console.warn("[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill");
  } else {
    var state = new VisibilityState(el, value, vnode);
    el._vue_visibilityState = state;
  }
}
function updated(el, _ref3, vnode) {
  var value = _ref3.value, oldValue = _ref3.oldValue;
  if (deepEqual(value, oldValue))
    return;
  var state = el._vue_visibilityState;
  if (!value) {
    unmounted(el);
    return;
  }
  if (state) {
    state.createObserver(value, vnode);
  } else {
    beforeMount(el, {
      value
    }, vnode);
  }
}
function unmounted(el) {
  var state = el._vue_visibilityState;
  if (state) {
    state.destroyObserver();
    delete el._vue_visibilityState;
  }
}
var ObserveVisibility = {
  beforeMount,
  updated,
  unmounted
};
var config = {
  itemsLimit: 1e3
};
var regex = /(auto|scroll)/;
function parents(node, ps) {
  if (node.parentNode === null) {
    return ps;
  }
  return parents(node.parentNode, ps.concat([node]));
}
var style = function style2(node, prop) {
  return getComputedStyle(node, null).getPropertyValue(prop);
};
var overflow = function overflow2(node) {
  return style(node, "overflow") + style(node, "overflow-y") + style(node, "overflow-x");
};
var scroll = function scroll2(node) {
  return regex.test(overflow(node));
};
function getScrollParent(node) {
  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {
    return;
  }
  var ps = parents(node.parentNode, []);
  for (var i = 0; i < ps.length; i += 1) {
    if (scroll(ps[i])) {
      return ps[i];
    }
  }
  return document.scrollingElement || document.documentElement;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var props = {
  items: {
    type: Array,
    required: true
  },
  keyField: {
    type: String,
    default: "id"
  },
  direction: {
    type: String,
    default: "vertical",
    validator: function validator(value) {
      return ["vertical", "horizontal"].includes(value);
    }
  }
};
function simpleArray() {
  return this.items.length && _typeof(this.items[0]) !== "object";
}
var supportsPassive = false;
if (typeof window !== "undefined") {
  supportsPassive = false;
  try {
    var opts = Object.defineProperty({}, "passive", {
      get: function get() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {
  }
}
let uid = 0;
var script$2 = {
  name: "RecycleScroller",
  components: {
    ResizeObserver: script
  },
  directives: {
    ObserveVisibility
  },
  props: {
    ...props,
    itemSize: {
      type: Number,
      default: null
    },
    minItemSize: {
      type: [Number, String],
      default: null
    },
    sizeField: {
      type: String,
      default: "size"
    },
    typeField: {
      type: String,
      default: "type"
    },
    buffer: {
      type: Number,
      default: 200
    },
    pageMode: {
      type: Boolean,
      default: false
    },
    prerender: {
      type: Number,
      default: 0
    },
    emitUpdate: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "resize",
    "visible",
    "hidden",
    "update"
  ],
  data() {
    return {
      pool: [],
      totalSize: 0,
      ready: false,
      hoverKey: null
    };
  },
  computed: {
    sizes() {
      if (this.itemSize === null) {
        const sizes = {
          "-1": { accumulator: 0 }
        };
        const items = this.items;
        const field = this.sizeField;
        const minItemSize = this.minItemSize;
        let computedMinSize = 1e4;
        let accumulator = 0;
        let current;
        for (let i = 0, l = items.length; i < l; i++) {
          current = items[i][field] || minItemSize;
          if (current < computedMinSize) {
            computedMinSize = current;
          }
          accumulator += current;
          sizes[i] = { accumulator, size: current };
        }
        this.$_computedMinItemSize = computedMinSize;
        return sizes;
      }
      return [];
    },
    simpleArray
  },
  watch: {
    items() {
      this.updateVisibleItems(true);
    },
    pageMode() {
      this.applyPageMode();
      this.updateVisibleItems(false);
    },
    sizes: {
      handler() {
        this.updateVisibleItems(false);
      },
      deep: true
    }
  },
  created() {
    this.$_startIndex = 0;
    this.$_endIndex = 0;
    this.$_views = /* @__PURE__ */ new Map();
    this.$_unusedViews = /* @__PURE__ */ new Map();
    this.$_scrollDirty = false;
    this.$_lastUpdateScrollPosition = 0;
    if (this.prerender) {
      this.$_prerender = true;
      this.updateVisibleItems(false);
    }
  },
  mounted() {
    this.applyPageMode();
    this.$nextTick(() => {
      this.$_prerender = false;
      this.updateVisibleItems(true);
      this.ready = true;
    });
  },
  beforeUnmount() {
    this.removeListeners();
  },
  methods: {
    addView(pool, index2, item, key, type) {
      const nr = markRaw({
        id: uid++,
        index: index2,
        used: true,
        key,
        type
      });
      const view = shallowReactive({
        item,
        position: 0,
        nr
      });
      pool.push(view);
      return view;
    },
    unuseView(view, fake = false) {
      const unusedViews = this.$_unusedViews;
      const type = view.nr.type;
      let unusedPool = unusedViews.get(type);
      if (!unusedPool) {
        unusedPool = [];
        unusedViews.set(type, unusedPool);
      }
      unusedPool.push(view);
      if (!fake) {
        view.nr.used = false;
        view.position = -9999;
        this.$_views.delete(view.nr.key);
      }
    },
    handleResize() {
      this.$emit("resize");
      if (this.ready)
        this.updateVisibleItems(false);
    },
    handleScroll(event) {
      if (!this.$_scrollDirty) {
        this.$_scrollDirty = true;
        requestAnimationFrame(() => {
          this.$_scrollDirty = false;
          const { continuous } = this.updateVisibleItems(false, true);
          if (!continuous) {
            clearTimeout(this.$_refreshTimout);
            this.$_refreshTimout = setTimeout(this.handleScroll, 100);
          }
        });
      }
    },
    handleVisibilityChange(isVisible, entry) {
      if (this.ready) {
        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {
          this.$emit("visible");
          requestAnimationFrame(() => {
            this.updateVisibleItems(false);
          });
        } else {
          this.$emit("hidden");
        }
      }
    },
    updateVisibleItems(checkItem, checkPositionDiff = false) {
      const itemSize = this.itemSize;
      const minItemSize = this.$_computedMinItemSize;
      const typeField = this.typeField;
      const keyField = this.simpleArray ? null : this.keyField;
      const items = this.items;
      const count = items.length;
      const sizes = this.sizes;
      const views = this.$_views;
      const unusedViews = this.$_unusedViews;
      const pool = this.pool;
      let startIndex, endIndex;
      let totalSize;
      if (!count) {
        startIndex = endIndex = totalSize = 0;
      } else if (this.$_prerender) {
        startIndex = 0;
        endIndex = this.prerender;
        totalSize = null;
      } else {
        const scroll3 = this.getScroll();
        if (checkPositionDiff) {
          let positionDiff = scroll3.start - this.$_lastUpdateScrollPosition;
          if (positionDiff < 0)
            positionDiff = -positionDiff;
          if (itemSize === null && positionDiff < minItemSize || positionDiff < itemSize) {
            return {
              continuous: true
            };
          }
        }
        this.$_lastUpdateScrollPosition = scroll3.start;
        const buffer = this.buffer;
        scroll3.start -= buffer;
        scroll3.end += buffer;
        if (itemSize === null) {
          let h;
          let a = 0;
          let b = count - 1;
          let i = ~~(count / 2);
          let oldI;
          do {
            oldI = i;
            h = sizes[i].accumulator;
            if (h < scroll3.start) {
              a = i;
            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll3.start) {
              b = i;
            }
            i = ~~((a + b) / 2);
          } while (i !== oldI);
          i < 0 && (i = 0);
          startIndex = i;
          totalSize = sizes[count - 1].accumulator;
          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll3.end; endIndex++)
            ;
          if (endIndex === -1) {
            endIndex = items.length - 1;
          } else {
            endIndex++;
            endIndex > count && (endIndex = count);
          }
        } else {
          startIndex = ~~(scroll3.start / itemSize);
          endIndex = Math.ceil(scroll3.end / itemSize);
          startIndex < 0 && (startIndex = 0);
          endIndex > count && (endIndex = count);
          totalSize = count * itemSize;
        }
      }
      if (endIndex - startIndex > config.itemsLimit) {
        this.itemsLimitError();
      }
      this.totalSize = totalSize;
      let view;
      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex;
      if (this.$_continuous !== continuous) {
        if (continuous) {
          views.clear();
          unusedViews.clear();
          for (let i = 0, l = pool.length; i < l; i++) {
            view = pool[i];
            this.unuseView(view);
          }
        }
        this.$_continuous = continuous;
      } else if (continuous) {
        for (let i = 0, l = pool.length; i < l; i++) {
          view = pool[i];
          if (view.nr.used) {
            if (checkItem) {
              view.nr.index = items.findIndex(
                (item2) => keyField ? item2[keyField] === view.item[keyField] : item2 === view.item
              );
            }
            if (view.nr.index === -1 || view.nr.index < startIndex || view.nr.index >= endIndex) {
              this.unuseView(view);
            }
          }
        }
      }
      const unusedIndex = continuous ? null : /* @__PURE__ */ new Map();
      let item, type, unusedPool;
      let v;
      for (let i = startIndex; i < endIndex; i++) {
        item = items[i];
        const key = keyField ? item[keyField] : item;
        if (key == null) {
          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`);
        }
        view = views.get(key);
        if (!itemSize && !sizes[i].size) {
          if (view)
            this.unuseView(view);
          continue;
        }
        if (!view) {
          type = item[typeField];
          unusedPool = unusedViews.get(type);
          if (continuous) {
            if (unusedPool && unusedPool.length) {
              view = unusedPool.pop();
              view.item = item;
              view.nr.used = true;
              view.nr.index = i;
              view.nr.key = key;
              view.nr.type = type;
            } else {
              view = this.addView(pool, i, item, key, type);
            }
          } else {
            v = unusedIndex.get(type) || 0;
            if (!unusedPool || v >= unusedPool.length) {
              view = this.addView(pool, i, item, key, type);
              this.unuseView(view, true);
              unusedPool = unusedViews.get(type);
            }
            view = unusedPool[v];
            view.item = item;
            view.nr.used = true;
            view.nr.index = i;
            view.nr.key = key;
            view.nr.type = type;
            unusedIndex.set(type, v + 1);
            v++;
          }
          views.set(key, view);
        } else {
          view.nr.used = true;
          view.item = item;
        }
        if (itemSize === null) {
          view.position = sizes[i - 1].accumulator;
        } else {
          view.position = i * itemSize;
        }
      }
      this.$_startIndex = startIndex;
      this.$_endIndex = endIndex;
      if (this.emitUpdate)
        this.$emit("update", startIndex, endIndex);
      clearTimeout(this.$_sortTimer);
      this.$_sortTimer = setTimeout(this.sortViews, 300);
      return {
        continuous
      };
    },
    getListenerTarget() {
      let target = getScrollParent(this.$el);
      if (window.document && (target === window.document.documentElement || target === window.document.body)) {
        target = window;
      }
      return target;
    },
    getScroll() {
      const { $el: el, direction } = this;
      const isVertical = direction === "vertical";
      let scrollState;
      if (this.pageMode) {
        const bounds = el.getBoundingClientRect();
        const boundsSize = isVertical ? bounds.height : bounds.width;
        let start = -(isVertical ? bounds.top : bounds.left);
        let size = isVertical ? window.innerHeight : window.innerWidth;
        if (start < 0) {
          size += start;
          start = 0;
        }
        if (start + size > boundsSize) {
          size = boundsSize - start;
        }
        scrollState = {
          start,
          end: start + size
        };
      } else if (isVertical) {
        scrollState = {
          start: el.scrollTop,
          end: el.scrollTop + el.clientHeight
        };
      } else {
        scrollState = {
          start: el.scrollLeft,
          end: el.scrollLeft + el.clientWidth
        };
      }
      return scrollState;
    },
    applyPageMode() {
      if (this.pageMode) {
        this.addListeners();
      } else {
        this.removeListeners();
      }
    },
    addListeners() {
      this.listenerTarget = this.getListenerTarget();
      this.listenerTarget.addEventListener("scroll", this.handleScroll, supportsPassive ? {
        passive: true
      } : false);
      this.listenerTarget.addEventListener("resize", this.handleResize);
    },
    removeListeners() {
      if (!this.listenerTarget) {
        return;
      }
      this.listenerTarget.removeEventListener("scroll", this.handleScroll);
      this.listenerTarget.removeEventListener("resize", this.handleResize);
      this.listenerTarget = null;
    },
    scrollToItem(index2) {
      let scroll3;
      if (this.itemSize === null) {
        scroll3 = index2 > 0 ? this.sizes[index2 - 1].accumulator : 0;
      } else {
        scroll3 = index2 * this.itemSize;
      }
      this.scrollToPosition(scroll3);
    },
    scrollToPosition(position) {
      if (this.direction === "vertical") {
        this.$el.scrollTop = position;
      } else {
        this.$el.scrollLeft = position;
      }
    },
    itemsLimitError() {
      setTimeout(() => {
        console.log("It seems the scroller element isn't scrolling, so it tries to render all the items at once.", "Scroller:", this.$el);
        console.log("Make sure the scroller has a fixed height (or width) and 'overflow-y' (or 'overflow-x') set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.");
      });
      throw new Error("Rendered items limit reached");
    },
    sortViews() {
      this.pool.sort((viewA, viewB) => viewA.index - viewB.index);
    }
  }
};
const _hoisted_1$2 = {
  key: 0,
  class: "vue-recycle-scroller__slot"
};
const _hoisted_2$1 = {
  key: 1,
  class: "vue-recycle-scroller__slot"
};
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  const _directive_observe_visibility = resolveDirective("observe-visibility");
  return withDirectives((openBlock(), createBlock("div", {
    class: ["vue-recycle-scroller", {
      ready: $data.ready,
      "page-mode": $props.pageMode,
      [`direction-${_ctx.direction}`]: true
    }],
    onScrollPassive: _cache[2] || (_cache[2] = (...args) => $options.handleScroll && $options.handleScroll(...args))
  }, [
    _ctx.$slots.before ? (openBlock(), createBlock("div", _hoisted_1$2, [
      renderSlot(_ctx.$slots, "before")
    ])) : createCommentVNode("v-if", true),
    createVNode("div", {
      ref: "wrapper",
      style: { [_ctx.direction === "vertical" ? "minHeight" : "minWidth"]: $data.totalSize + "px" },
      class: "vue-recycle-scroller__item-wrapper"
    }, [
      (openBlock(true), createBlock(Fragment, null, renderList($data.pool, (view) => {
        return openBlock(), createBlock("div", {
          key: view.nr.id,
          style: $data.ready ? { transform: `translate${_ctx.direction === "vertical" ? "Y" : "X"}(${view.position}px)` } : null,
          class: ["vue-recycle-scroller__item-view", { hover: $data.hoverKey === view.nr.key }],
          onMouseenter: ($event) => $data.hoverKey = view.nr.key,
          onMouseleave: _cache[1] || (_cache[1] = ($event) => $data.hoverKey = null)
        }, [
          renderSlot(_ctx.$slots, "default", {
            item: view.item,
            index: view.nr.index,
            active: view.nr.used
          })
        ], 46, ["onMouseenter"]);
      }), 128))
    ], 4),
    _ctx.$slots.after ? (openBlock(), createBlock("div", _hoisted_2$1, [
      renderSlot(_ctx.$slots, "after")
    ])) : createCommentVNode("v-if", true),
    createVNode(_component_ResizeObserver, { onNotify: $options.handleResize }, null, 8, ["onNotify"])
  ], 34)), [
    [_directive_observe_visibility, $options.handleVisibilityChange]
  ]);
}
script$2.render = render$1;
script$2.__file = "src/components/RecycleScroller.vue";
class BaseTreeNode {
  constructor(options, parent) {
    __publicField(this, "key");
    __publicField(this, "name");
    __publicField(this, "level");
    __publicField(this, "loading", false);
    __publicField(this, "hasChildren", false);
    __publicField(this, "showCheckbox");
    __publicField(this, "children", []);
    __publicField(this, "parentKey");
    __publicField(this, "parentKeys", []);
    __publicField(this, "origin");
    this.key = options.nodeKey;
    this.name = options.name;
    this.showCheckbox = options.showCheckbox;
    this.parentKey = parent == null ? void 0 : parent.key;
    this.parentKeys = parent ? [...parent.parentKeys, parent.key] : [];
    this.level = parent ? parent.level + 1 : 0;
    this.origin = toRaw(options);
  }
}
function useTreeData(source) {
  const treeData = coerceTreeNodes(source);
  const flattenTreeData = getFlattenTreeData(treeData);
  const key2TreeNode = getKey2TreeNode(flattenTreeData);
  return { treeData, flattenTreeData, key2TreeNode };
}
function coerceTreeNodes(source, parent) {
  const recursion = (list, parentNode) => {
    return list.map((item) => {
      var _a;
      const node = item instanceof BaseTreeNode ? item : new BaseTreeNode(item, parentNode);
      node.children = ((_a = item.children) == null ? void 0 : _a.length) ? recursion(item.children, node) : [];
      node.hasChildren = item.hasChildren || node.children.length > 0;
      return node;
    });
  };
  return recursion(source, parent);
}
function getFlattenTreeData(tree2) {
  const nodes = [];
  function recursion(list) {
    list.forEach((node) => {
      nodes.push(node);
      recursion(node.children);
    });
  }
  recursion(tree2);
  return nodes;
}
function getKey2TreeNode(flattenTreeData) {
  const key2TreeNode = {};
  flattenTreeData.forEach((node) => {
    key2TreeNode[node.key] = node;
  });
  return key2TreeNode;
}
const _hoisted_1$1 = /* @__PURE__ */ createElementVNode("div", { class: "inner" }, null, -1);
const _hoisted_2 = { class: "content" };
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    halfChecked: {
      type: Boolean,
      default: false
    }
  },
  emits: ["change", "update:modelValue"],
  setup(__props, { emit }) {
    const props2 = __props;
    const rootCls = computed(() => {
      let result = "vir-checkbox";
      if (props2.modelValue) {
        result += " checked";
      } else if (props2.halfChecked) {
        result += " half-checked";
      }
      if (props2.disabled) {
        result += " disabled";
      }
      return result;
    });
    const handleClick = (event) => {
      event.stopPropagation();
      if (!props2.disabled) {
        emit("update:modelValue", !props2.modelValue);
        emit("change", !props2.modelValue);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(rootCls)),
        onClick: handleClick
      }, [
        _hoisted_1$1,
        createElementVNode("div", _hoisted_2, [
          renderSlot(_ctx.$slots, "default")
        ])
      ], 2);
    };
  }
});
var RenderNode = defineComponent({
  name: "RenderNode",
  props: {
    titleCls: String,
    node: {
      type: Object,
      required: true
    },
    context: {
      type: Object,
      required: true
    }
  },
  setup(props2) {
    const {
      context,
      node,
      titleCls
    } = toRefs(props2);
    return () => {
      return context.value.renderNode ? context.value.renderNode(node.value) : context.value.slots.node ? renderSlot(context.value.slots, "node", {
        node: node.value
      }) : createVNode("span", {
        "class": titleCls.value
      }, [node.value.name]);
    };
  }
});
var renderIcon = defineComponent({
  name: "RenderIcon",
  props: {
    node: {
      type: Object,
      required: true
    },
    context: {
      type: Object,
      required: true
    }
  },
  setup({
    context,
    node
  }) {
    const {
      loading,
      key
    } = toRefs(node);
    const {
      expandedKeys,
      renderIcon: renderIcon2,
      slots
    } = context;
    const expanded = computed(() => expandedKeys.has(key.value));
    return () => {
      return renderIcon2 ? renderIcon2({
        node,
        loading: loading.value,
        expanded: expanded.value
      }) : slots.icon ? renderSlot(slots, "icon", {
        node,
        loading: loading.value,
        expanded: expanded.value
      }) : createVNode("div", {
        "class": "def-arrow"
      }, [loading.value ? createVNode("i", {
        "class": "iconfont iconloading ico-loading"
      }, null) : createVNode("i", {
        "class": "iconfont iconExpand"
      }, null)]);
    };
  }
});
const TreeInjectionKey = Symbol("TreeInjectionKey");
const __default__ = defineComponent({
  name: "TreeNode"
});
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...__default__,
  props: {
    node: {
      type: Object,
      required: true
    },
    selectedKeys: {
      type: Object,
      required: true
    },
    focusKey: {
      type: [String, Number]
    },
    expandedKeys: {
      type: Object,
      required: true
    },
    disabledKeys: {
      type: Object,
      required: true
    },
    checkedKeys: {
      type: Set,
      required: true
    },
    halfCheckedKeys: {
      type: Set,
      required: true
    },
    showCheckbox: {
      type: Boolean,
      default: false
    }
  },
  emits: ["selectChange", "checkChange", "toggleExpand"],
  setup(__props, { emit }) {
    const props2 = __props;
    const showArrow = computed(() => props2.node.hasChildren);
    const showCheckbox = computed(() => {
      if (props2.node.showCheckbox !== void 0) {
        return props2.node.showCheckbox;
      }
      return props2.showCheckbox;
    });
    const treeContext = inject(TreeInjectionKey);
    const treeNodeStyle = computed(() => ({
      "--vir-tree-level": props2.node.level
    }));
    const titleCls = computed(() => {
      let result = "node-title";
      if (props2.focusKey === props2.node.key) {
        result += " focused";
      }
      if (props2.selectedKeys.has(props2.node.key)) {
        result += " selected";
      }
      if (props2.disabledKeys.has(props2.node.key)) {
        result += " disabled";
      }
      return result;
    });
    const handleSelect = (event) => {
      event.stopPropagation();
      if (!props2.disabledKeys.has(props2.node.key)) {
        emit("selectChange", props2.node);
      }
    };
    const handleCheckChange = () => {
      emit("checkChange", props2.node);
    };
    const handleExpand = () => {
      if (showArrow) {
        emit("toggleExpand", {
          state: !treeContext.expandedKeys.has(props2.node.key),
          node: props2.node
        });
      }
    };
    const arrowClick = (event) => {
      event.stopPropagation();
      handleExpand();
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "vir-tree-node",
        style: normalizeStyle(unref(treeNodeStyle)),
        onClick: handleExpand
      }, [
        createElementVNode("div", {
          onClick: arrowClick,
          class: normalizeClass(["node-arrow", props2.expandedKeys.has(props2.node.key) ? "expanded" : ""])
        }, [
          unref(showArrow) ? (openBlock(), createBlock(unref(renderIcon), {
            key: 0,
            context: unref(treeContext),
            node: props2.node
          }, null, 8, ["context", "node"])) : createCommentVNode("", true)
        ], 2),
        unref(showCheckbox) ? (openBlock(), createBlock(_sfc_main$2, {
          key: 0,
          class: "node-content node-check-box",
          disabled: props2.disabledKeys.has(props2.node.key),
          modelValue: props2.checkedKeys.has(props2.node.key),
          halfChecked: props2.halfCheckedKeys.has(props2.node.key),
          onChange: handleCheckChange
        }, {
          default: withCtx(() => [
            createVNode(unref(RenderNode), {
              "title-cls": unref(titleCls),
              context: unref(treeContext),
              node: props2.node
            }, null, 8, ["title-cls", "context", "node"])
          ]),
          _: 1
        }, 8, ["disabled", "modelValue", "halfChecked"])) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: "node-content node-text",
          onClick: handleSelect
        }, [
          createVNode(unref(RenderNode), {
            "title-cls": unref(titleCls),
            context: unref(treeContext),
            node: props2.node
          }, null, 8, ["title-cls", "context", "node"])
        ]))
      ], 4);
    };
  }
});
function addOrDelete(checked) {
  return checked ? "add" : "delete";
}
function useCheckState(defaultCheckedKeys, { checkedKeys, halfCheckedKeys, checkStrictly, key2TreeNode }) {
  checkedKeys.clear();
  halfCheckedKeys.clear();
  defaultCheckedKeys.forEach((key) => {
    if (!checkedKeys.has(key)) {
      const node = key2TreeNode[key];
      if (node) {
        updateCheckedState({
          node,
          checked: true,
          checkedKeys,
          halfCheckedKeys,
          key2TreeNode,
          checkStrictly
        });
      } else {
        checkedKeys.add(key);
      }
    }
  });
}
function updateCheckedState(options) {
  const {
    node,
    checked,
    checkedKeys,
    halfCheckedKeys,
    key2TreeNode,
    checkStrictly
  } = options;
  checkedKeys[addOrDelete(checked)](node.key);
  halfCheckedKeys.delete(node.key);
  if (!checkStrictly) {
    updateChildrenCheckState({
      node,
      checked,
      checkedKeys,
      halfCheckedKeys
    });
    updateUpwards({
      node,
      key2TreeNode,
      checkedKeys,
      halfCheckedKeys
    });
  }
}
function updateChildrenCheckState(options) {
  const { node, checked, checkedKeys, halfCheckedKeys } = options;
  const setFunc = addOrDelete(checked);
  const update = (list) => {
    if (list.length) {
      list.forEach((child) => {
        var _a;
        checkedKeys[setFunc](child.key);
        halfCheckedKeys.delete(child.key);
        if ((_a = child.children) == null ? void 0 : _a.length) {
          update(child.children);
        }
      });
    }
  };
  update(node.children);
}
function updateUpwards(options) {
  const { node, checkedKeys, halfCheckedKeys, key2TreeNode } = options;
  const update = (node2) => {
    if (node2.parentKey) {
      const parentNode = key2TreeNode[node2.parentKey];
      const { key: parentKey, children } = parentNode;
      const { checked, indeterminate } = getStateFromNodes({
        nodes: children,
        checkedKeys,
        halfCheckedKeys
      });
      if (checked !== checkedKeys.has(parentKey) || indeterminate !== halfCheckedKeys.has(parentKey)) {
        checkedKeys[addOrDelete(checked)](parentKey);
        halfCheckedKeys[addOrDelete(indeterminate)](parentKey);
        update(parentNode);
      }
    }
  };
  update(node);
}
function getStateFromNodes(options) {
  const { nodes, checkedKeys, halfCheckedKeys } = options;
  let checkedCount = 0;
  let indeterminate = false;
  for (let i = 0; i < nodes.length; i++) {
    const child = nodes[i];
    const childChecked = checkedKeys.has(child.key);
    const childIndeterminate = halfCheckedKeys.has(child.key);
    if (childChecked) {
      checkedCount++;
    }
    if (childIndeterminate || !childChecked && checkedCount > 0) {
      indeterminate = true;
      break;
    }
  }
  const checked = checkedCount === nodes.length;
  return {
    checked,
    indeterminate: indeterminate || !checked && checkedCount > 0
  };
}
const _hoisted_1 = {
  key: 1,
  class: "vir-tree-wrap"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  props: {
    source: {
      type: Array,
      default: []
    },
    defaultSelectedKey: {
      type: [String, Number],
      default: ""
    },
    defaultExpandedKeys: {
      type: Array,
      default: []
    },
    defaultCheckedKeys: {
      type: Array,
      default: []
    },
    defaultDisabledKeys: {
      type: Array,
      default: []
    },
    showCheckbox: {
      type: Boolean,
      default: false
    },
    checkStrictly: {
      type: Boolean,
      default: false
    },
    renderNode: Function,
    renderIcon: Function,
    loadData: Function,
    virtual: Object
  },
  emits: ["selectChange", "checkChange", "expandChange", "focusChange", "keydown"],
  setup(__props, { expose, emit }) {
    const props2 = __props;
    const flattenTreeData = ref([]);
    const key2TreeNode = ref({});
    watch(() => props2.source, (newVal) => {
      const result = useTreeData(newVal);
      flattenTreeData.value = result.flattenTreeData;
      key2TreeNode.value = result.key2TreeNode;
    }, {
      immediate: true
    });
    const disabledKeys = ref(/* @__PURE__ */ new Set());
    watch(() => props2.defaultDisabledKeys, (newVal) => {
      disabledKeys.value.clear();
      disabledKeys.value = new Set(newVal);
    }, {
      immediate: true
    });
    const checkedKeys = ref(/* @__PURE__ */ new Set());
    const halfCheckedKeys = ref(/* @__PURE__ */ new Set());
    watch(() => props2.defaultCheckedKeys, (newVal) => {
      useCheckState(newVal, {
        checkedKeys: checkedKeys.value,
        halfCheckedKeys: halfCheckedKeys.value,
        checkStrictly: props2.checkStrictly,
        key2TreeNode: key2TreeNode.value
      });
    }, {
      immediate: true
    });
    watchEffect(() => {
    });
    const visibleList = computed(() => {
      return flattenTreeData.value.filter((node) => {
        const isRoot = !node.parentKey;
        const isVisibleNode = node.parentKeys.every((key) => expandedKeys.value.has(key));
        return isRoot || isVisibleNode;
      });
    });
    const virtualHeight = computed(() => {
      if (props2.virtual) {
        return +(props2.virtual.size * props2.virtual.remain) || 0;
      }
      return 0;
    });
    const expandedKeys = ref(/* @__PURE__ */ new Set());
    watch(() => props2.defaultExpandedKeys, (newVal) => {
      expandedKeys.value.clear();
      expandedKeys.value = new Set(newVal);
    }, {
      immediate: true
    });
    const loading = ref(false);
    function toggleExpand({ state, node, source }) {
      if (loading.value)
        return;
      expandedKeys.value[addOrDelete(state)](node.key);
      if (state && !node.children.length && props2.loadData) {
        node.loading = true;
        loading.value = true;
        props2.loadData(node, (children) => {
          node.loading = false;
          loading.value = false;
          if (children.length) {
            lazyLoad(node, children);
            useCheckState([...checkedKeys.value], {
              checkedKeys: checkedKeys.value,
              halfCheckedKeys: halfCheckedKeys.value,
              checkStrictly: props2.checkStrictly,
              key2TreeNode: key2TreeNode.value
            });
          } else {
            node.children = [];
            node.hasChildren = false;
          }
        });
      }
      emit("expandChange", { state, node, source: source || "click" });
    }
    function lazyLoad(node, children) {
      const indexInFlattenData = flattenTreeData.value.findIndex((item) => item.key === node.key);
      const childrenData = coerceTreeNodes(children, node);
      node.children = childrenData;
      const childrenFlattenData = getFlattenTreeData(childrenData);
      flattenTreeData.value.splice(indexInFlattenData + 1, 0, ...childrenFlattenData);
      const key2ChildrenNode = getKey2TreeNode(childrenFlattenData);
      Object.assign(key2TreeNode.value, key2ChildrenNode);
      childrenFlattenData.forEach(async (item) => {
        if (expandedKeys.value.has(item.key)) {
          await nextTick();
          toggleExpand({ state: true, node: item });
        }
      });
    }
    const selectedKeys = ref(/* @__PURE__ */ new Set());
    watch(() => props2.defaultSelectedKey, (newVal) => {
      selectedKeys.value.clear();
      selectedKeys.value.add(newVal);
    }, {
      immediate: true
    });
    const selectedNode = computed(() => key2TreeNode.value[Array.from(selectedKeys.value.values())[0]]);
    const focusKey = ref();
    function focusChange(node) {
      if (!node) {
        return;
      }
      focusKey.value = node.key;
      emit("focusChange", { node });
    }
    function onFocusOut() {
      focusKey.value = void 0;
      emit("focusChange", { node: null });
    }
    function onFocusIn() {
      var _a;
      if (!focusKey.value) {
        focusChange((_a = flattenTreeData.value) == null ? void 0 : _a.at(0));
      }
    }
    function handleKeyboardNavigation(event) {
      const { key } = event;
      if (!focusKey.value) {
        return;
      }
      const currentFocusedNode = key2TreeNode.value[focusKey.value];
      const getNextNode = (node, offset) => {
        var _a;
        if (!node) {
          return;
        }
        const index2 = visibleList.value.findIndex(({ key: key2 }) => key2 === node.key);
        return (_a = visibleList.value) == null ? void 0 : _a[index2 + offset];
      };
      const arrowRight = () => {
        event.stopPropagation();
        event.preventDefault();
        if (currentFocusedNode.hasChildren) {
          if (expandedKeys.value.has(currentFocusedNode.key)) {
            focusChange(getNextNode(currentFocusedNode, 1));
          } else {
            toggleExpand({ node: currentFocusedNode, state: true, source: "key" });
          }
        }
      };
      const arrowLeft = () => {
        event.stopPropagation();
        event.preventDefault();
        if (expandedKeys.value.has(currentFocusedNode.key)) {
          toggleExpand({ node: currentFocusedNode, state: false, source: "key" });
        } else {
          if (currentFocusedNode.parentKey) {
            focusChange(key2TreeNode.value[currentFocusedNode.parentKey]);
          }
        }
      };
      switch (key) {
        case "ArrowUp":
          event.preventDefault();
          focusChange(getNextNode(currentFocusedNode, -1));
          break;
        case "ArrowDown":
          event.preventDefault();
          focusChange(getNextNode(currentFocusedNode, 1));
          break;
        case "ArrowLeft":
          event.preventDefault();
          arrowLeft();
          break;
        case "ArrowRight":
          event.preventDefault();
          arrowRight();
          break;
      }
      emit("keydown", { event, node: currentFocusedNode });
    }
    function selectChange(node) {
      const preSelectedNode = key2TreeNode.value[Array.from(selectedKeys.value.values())[0]];
      let currentNode;
      if (selectedKeys.value.has(node.key)) {
        selectedKeys.value.clear();
      } else {
        selectedKeys.value.clear();
        selectedKeys.value.add(node.key);
        currentNode = node;
      }
      emit("selectChange", { preSelectedNode, node: currentNode });
    }
    function checkChange(node) {
      const newChecked = !checkedKeys.value.has(node.key);
      updateCheckedState({
        node,
        checked: newChecked,
        checkedKeys: checkedKeys.value,
        halfCheckedKeys: halfCheckedKeys.value,
        key2TreeNode: key2TreeNode.value,
        checkStrictly: props2.checkStrictly
      });
      emit("checkChange", { state: newChecked, node });
    }
    const context = shallowReactive({
      renderNode: props2.renderNode,
      renderIcon: props2.renderIcon,
      slots: useSlots(),
      expandedKeys: expandedKeys.value,
      getExpandedKeys: () => [...expandedKeys.value],
      getSelectedNode: () => selectedNode.value,
      getCheckedNodes: () => Array.from(checkedKeys.value).map((key) => key2TreeNode.value[key]).filter(Boolean),
      getHalfCheckedNodes: () => Array.from(halfCheckedKeys.value).map((key) => key2TreeNode.value[key]),
      toggleExpand: (nodeKey, state) => toggleExpand({ state: state != null ? state : !expandedKeys.value.has(nodeKey), node: key2TreeNode.value[nodeKey], source: "api" })
    });
    expose(toRaw(context));
    provide(TreeInjectionKey, context);
    return (_ctx, _cache) => {
      var _a;
      return openBlock(), createElementBlock("div", {
        class: "vir-tree",
        tabindex: "0",
        onKeydown: handleKeyboardNavigation,
        onFocusin: onFocusIn,
        onFocusout: onFocusOut
      }, [
        unref(virtualHeight) ? (openBlock(), createBlock(unref(script$2), {
          key: 0,
          class: "vir-tree-wrap",
          style: normalizeStyle({ height: unref(virtualHeight) + "px" }),
          items: unref(visibleList),
          "item-size": (_a = props2.virtual) == null ? void 0 : _a.size,
          "key-field": "key"
        }, {
          default: withCtx(({ item }) => [
            (openBlock(), createBlock(_sfc_main$1, {
              node: item,
              key: item.key,
              "show-checkbox": __props.showCheckbox,
              "selected-keys": selectedKeys.value,
              "disabled-keys": disabledKeys.value,
              "expanded-keys": expandedKeys.value,
              "checked-keys": checkedKeys.value,
              "focus-key": focusKey.value,
              "half-checked-keys": halfCheckedKeys.value,
              onToggleExpand: toggleExpand,
              onSelectChange: selectChange,
              onCheckChange: checkChange
            }, null, 8, ["node", "show-checkbox", "selected-keys", "disabled-keys", "expanded-keys", "checked-keys", "focus-key", "half-checked-keys"]))
          ]),
          _: 1
        }, 8, ["style", "items", "item-size"])) : (openBlock(), createElementBlock("div", _hoisted_1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(visibleList), (item) => {
            return openBlock(), createBlock(_sfc_main$1, {
              key: item.key,
              node: item,
              "show-checkbox": __props.showCheckbox,
              "selected-keys": selectedKeys.value,
              "disabled-keys": disabledKeys.value,
              "expanded-keys": expandedKeys.value,
              "focus-key": focusKey.value,
              "checked-keys": checkedKeys.value,
              "half-checked-keys": halfCheckedKeys.value,
              onToggleExpand: toggleExpand,
              onSelectChange: selectChange,
              onCheckChange: checkChange
            }, null, 8, ["node", "show-checkbox", "selected-keys", "disabled-keys", "expanded-keys", "focus-key", "checked-keys", "half-checked-keys"]);
          }), 128))
        ]))
      ], 32);
    };
  }
});
var tree = Object.assign(_sfc_main, {
  install: (app) => {
    app.component("VirTree", _sfc_main);
  }
});
export { tree as default };
