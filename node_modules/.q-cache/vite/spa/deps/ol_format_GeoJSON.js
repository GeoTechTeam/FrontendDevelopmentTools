import {
  Feature_default,
  LineString_default,
  MultiLineString_default,
  MultiPoint_default,
  MultiPolygon_default
} from "./chunk-5Z3WTK4W.js";
import {
  Point_default,
  Polygon_default
} from "./chunk-QPGFFNEB.js";
import "./chunk-YAG7NNW4.js";
import "./chunk-YIGQHVJG.js";
import {
  Geometry_default
} from "./chunk-QSB3DSC5.js";
import "./chunk-MHRSOZZM.js";
import "./chunk-KMVUSSNA.js";
import {
  EventType_default,
  Units_default,
  abstract,
  assert,
  assign,
  closestSquaredDistanceXY,
  createOrUpdateEmpty,
  equivalent,
  extend2 as extend,
  get,
  getCenter,
  isEmpty,
  listen,
  unlistenByKey
} from "./chunk-RL3BDFZF.js";

// node_modules/ol/geom/GeometryCollection.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GeometryCollection = function(_super) {
  __extends(GeometryCollection2, _super);
  function GeometryCollection2(opt_geometries) {
    var _this = _super.call(this) || this;
    _this.geometries_ = opt_geometries ? opt_geometries : null;
    _this.changeEventsKeys_ = [];
    _this.listenGeometriesChange_();
    return _this;
  }
  GeometryCollection2.prototype.unlistenGeometriesChange_ = function() {
    this.changeEventsKeys_.forEach(unlistenByKey);
    this.changeEventsKeys_.length = 0;
  };
  GeometryCollection2.prototype.listenGeometriesChange_ = function() {
    if (!this.geometries_) {
      return;
    }
    for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {
      this.changeEventsKeys_.push(listen(this.geometries_[i], EventType_default.CHANGE, this.changed, this));
    }
  };
  GeometryCollection2.prototype.clone = function() {
    var geometryCollection = new GeometryCollection2(null);
    geometryCollection.setGeometries(this.geometries_);
    geometryCollection.applyProperties(this);
    return geometryCollection;
  };
  GeometryCollection2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
    }
    return minSquaredDistance;
  };
  GeometryCollection2.prototype.containsXY = function(x, y) {
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].containsXY(x, y)) {
        return true;
      }
    }
    return false;
  };
  GeometryCollection2.prototype.computeExtent = function(extent) {
    createOrUpdateEmpty(extent);
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      extend(extent, geometries[i].getExtent());
    }
    return extent;
  };
  GeometryCollection2.prototype.getGeometries = function() {
    return cloneGeometries(this.geometries_);
  };
  GeometryCollection2.prototype.getGeometriesArray = function() {
    return this.geometries_;
  };
  GeometryCollection2.prototype.getGeometriesArrayRecursive = function() {
    var geometriesArray = [];
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].getType() === this.getType()) {
        geometriesArray = geometriesArray.concat(
          geometries[i].getGeometriesArrayRecursive()
        );
      } else {
        geometriesArray.push(geometries[i]);
      }
    }
    return geometriesArray;
  };
  GeometryCollection2.prototype.getSimplifiedGeometry = function(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    var simplifiedGeometries = [];
    var geometries = this.geometries_;
    var simplified = false;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      var geometry = geometries[i];
      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);
      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }
    if (simplified) {
      var simplifiedGeometryCollection = new GeometryCollection2(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      return simplifiedGeometryCollection;
    } else {
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  };
  GeometryCollection2.prototype.getType = function() {
    return "GeometryCollection";
  };
  GeometryCollection2.prototype.intersectsExtent = function(extent) {
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].intersectsExtent(extent)) {
        return true;
      }
    }
    return false;
  };
  GeometryCollection2.prototype.isEmpty = function() {
    return this.geometries_.length === 0;
  };
  GeometryCollection2.prototype.rotate = function(angle, anchor) {
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].rotate(angle, anchor);
    }
    this.changed();
  };
  GeometryCollection2.prototype.scale = function(sx, opt_sy, opt_anchor) {
    var anchor = opt_anchor;
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].scale(sx, opt_sy, anchor);
    }
    this.changed();
  };
  GeometryCollection2.prototype.setGeometries = function(geometries) {
    this.setGeometriesArray(cloneGeometries(geometries));
  };
  GeometryCollection2.prototype.setGeometriesArray = function(geometries) {
    this.unlistenGeometriesChange_();
    this.geometries_ = geometries;
    this.listenGeometriesChange_();
    this.changed();
  };
  GeometryCollection2.prototype.applyTransform = function(transformFn) {
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].applyTransform(transformFn);
    }
    this.changed();
  };
  GeometryCollection2.prototype.translate = function(deltaX, deltaY) {
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].translate(deltaX, deltaY);
    }
    this.changed();
  };
  GeometryCollection2.prototype.disposeInternal = function() {
    this.unlistenGeometriesChange_();
    _super.prototype.disposeInternal.call(this);
  };
  return GeometryCollection2;
}(Geometry_default);
function cloneGeometries(geometries) {
  var clonedGeometries = [];
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    clonedGeometries.push(geometries[i].clone());
  }
  return clonedGeometries;
}
var GeometryCollection_default = GeometryCollection;

// node_modules/ol/format/Feature.js
var FeatureFormat = function() {
  function FeatureFormat2() {
    this.dataProjection = void 0;
    this.defaultFeatureProjection = void 0;
    this.supportedMediaTypes = null;
  }
  FeatureFormat2.prototype.getReadOptions = function(source, opt_options) {
    var options;
    if (opt_options) {
      var dataProjection = opt_options.dataProjection ? get(opt_options.dataProjection) : this.readProjection(source);
      if (opt_options.extent && dataProjection && dataProjection.getUnits() === Units_default.TILE_PIXELS) {
        dataProjection = get(dataProjection);
        dataProjection.setWorldExtent(opt_options.extent);
      }
      options = {
        dataProjection,
        featureProjection: opt_options.featureProjection
      };
    }
    return this.adaptOptions(options);
  };
  FeatureFormat2.prototype.adaptOptions = function(options) {
    return assign({
      dataProjection: this.dataProjection,
      featureProjection: this.defaultFeatureProjection
    }, options);
  };
  FeatureFormat2.prototype.getType = function() {
    return abstract();
  };
  FeatureFormat2.prototype.readFeature = function(source, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.readFeatures = function(source, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.readGeometry = function(source, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.readProjection = function(source) {
    return abstract();
  };
  FeatureFormat2.prototype.writeFeature = function(feature, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.writeFeatures = function(features, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.writeGeometry = function(geometry, opt_options) {
    return abstract();
  };
  return FeatureFormat2;
}();
var Feature_default2 = FeatureFormat;
function transformGeometryWithOptions(geometry, write, opt_options) {
  var featureProjection = opt_options ? get(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? get(opt_options.dataProjection) : null;
  var transformed;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
  } else {
    transformed = geometry;
  }
  if (write && opt_options && opt_options.decimals !== void 0) {
    var power_1 = Math.pow(
      10,
      opt_options.decimals
    );
    var transform = function(coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;
      }
      return coordinates;
    };
    if (transformed === geometry) {
      transformed = geometry.clone();
    }
    transformed.applyTransform(transform);
  }
  return transformed;
}

// node_modules/ol/format/JSONFeature.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var JSONFeature = function(_super) {
  __extends2(JSONFeature2, _super);
  function JSONFeature2() {
    return _super.call(this) || this;
  }
  JSONFeature2.prototype.getType = function() {
    return "json";
  };
  JSONFeature2.prototype.readFeature = function(source, opt_options) {
    return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readFeatures = function(source, opt_options) {
    return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readFeatureFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readFeaturesFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readGeometry = function(source, opt_options) {
    return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readGeometryFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readProjection = function(source) {
    return this.readProjectionFromObject(getObject(source));
  };
  JSONFeature2.prototype.readProjectionFromObject = function(object) {
    return abstract();
  };
  JSONFeature2.prototype.writeFeature = function(feature, opt_options) {
    return JSON.stringify(this.writeFeatureObject(feature, opt_options));
  };
  JSONFeature2.prototype.writeFeatureObject = function(feature, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.writeFeatures = function(features, opt_options) {
    return JSON.stringify(this.writeFeaturesObject(features, opt_options));
  };
  JSONFeature2.prototype.writeFeaturesObject = function(features, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.writeGeometry = function(geometry, opt_options) {
    return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
  };
  JSONFeature2.prototype.writeGeometryObject = function(geometry, opt_options) {
    return abstract();
  };
  return JSONFeature2;
}(Feature_default2);
function getObject(source) {
  if (typeof source === "string") {
    var object = JSON.parse(source);
    return object ? object : null;
  } else if (source !== null) {
    return source;
  } else {
    return null;
  }
}
var JSONFeature_default = JSONFeature;

// node_modules/ol/format/GeoJSON.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GeoJSON = function(_super) {
  __extends3(GeoJSON2, _super);
  function GeoJSON2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this) || this;
    _this.dataProjection = get(options.dataProjection ? options.dataProjection : "EPSG:4326");
    if (options.featureProjection) {
      _this.defaultFeatureProjection = get(options.featureProjection);
    }
    _this.geometryName_ = options.geometryName;
    _this.extractGeometryName_ = options.extractGeometryName;
    _this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
    return _this;
  }
  GeoJSON2.prototype.readFeatureFromObject = function(object, opt_options) {
    var geoJSONFeature = null;
    if (object["type"] === "Feature") {
      geoJSONFeature = object;
    } else {
      geoJSONFeature = {
        "type": "Feature",
        "geometry": object,
        "properties": null
      };
    }
    var geometry = readGeometry(geoJSONFeature["geometry"], opt_options);
    var feature = new Feature_default();
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    } else if (this.extractGeometryName_ && "geometry_name" in geoJSONFeature !== void 0) {
      feature.setGeometryName(geoJSONFeature["geometry_name"]);
    }
    feature.setGeometry(geometry);
    if ("id" in geoJSONFeature) {
      feature.setId(geoJSONFeature["id"]);
    }
    if (geoJSONFeature["properties"]) {
      feature.setProperties(geoJSONFeature["properties"], true);
    }
    return feature;
  };
  GeoJSON2.prototype.readFeaturesFromObject = function(object, opt_options) {
    var geoJSONObject = object;
    var features = null;
    if (geoJSONObject["type"] === "FeatureCollection") {
      var geoJSONFeatureCollection = object;
      features = [];
      var geoJSONFeatures = geoJSONFeatureCollection["features"];
      for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
        features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
      }
    } else {
      features = [this.readFeatureFromObject(object, opt_options)];
    }
    return features;
  };
  GeoJSON2.prototype.readGeometryFromObject = function(object, opt_options) {
    return readGeometry(object, opt_options);
  };
  GeoJSON2.prototype.readProjectionFromObject = function(object) {
    var crs = object["crs"];
    var projection;
    if (crs) {
      if (crs["type"] == "name") {
        projection = get(crs["properties"]["name"]);
      } else if (crs["type"] === "EPSG") {
        projection = get("EPSG:" + crs["properties"]["code"]);
      } else {
        assert(false, 36);
      }
    } else {
      projection = this.dataProjection;
    }
    return projection;
  };
  GeoJSON2.prototype.writeFeatureObject = function(feature, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var object = {
      "type": "Feature",
      geometry: null,
      properties: null
    };
    var id = feature.getId();
    if (id !== void 0) {
      object.id = id;
    }
    if (!feature.hasProperties()) {
      return object;
    }
    var properties = feature.getProperties();
    var geometry = feature.getGeometry();
    if (geometry) {
      object.geometry = writeGeometry(geometry, opt_options);
      delete properties[feature.getGeometryName()];
    }
    if (!isEmpty(properties)) {
      object.properties = properties;
    }
    return object;
  };
  GeoJSON2.prototype.writeFeaturesObject = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var objects = [];
    for (var i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], opt_options));
    }
    return {
      type: "FeatureCollection",
      features: objects
    };
  };
  GeoJSON2.prototype.writeGeometryObject = function(geometry, opt_options) {
    return writeGeometry(geometry, this.adaptOptions(opt_options));
  };
  return GeoJSON2;
}(JSONFeature_default);
function readGeometry(object, opt_options) {
  if (!object) {
    return null;
  }
  var geometry;
  switch (object["type"]) {
    case "Point": {
      geometry = readPointGeometry(object);
      break;
    }
    case "LineString": {
      geometry = readLineStringGeometry(
        object
      );
      break;
    }
    case "Polygon": {
      geometry = readPolygonGeometry(object);
      break;
    }
    case "MultiPoint": {
      geometry = readMultiPointGeometry(
        object
      );
      break;
    }
    case "MultiLineString": {
      geometry = readMultiLineStringGeometry(
        object
      );
      break;
    }
    case "MultiPolygon": {
      geometry = readMultiPolygonGeometry(
        object
      );
      break;
    }
    case "GeometryCollection": {
      geometry = readGeometryCollectionGeometry(
        object
      );
      break;
    }
    default: {
      throw new Error("Unsupported GeoJSON type: " + object["type"]);
    }
  }
  return transformGeometryWithOptions(geometry, false, opt_options);
}
function readGeometryCollectionGeometry(object, opt_options) {
  var geometries = object["geometries"].map(
    function(geometry) {
      return readGeometry(geometry, opt_options);
    }
  );
  return new GeometryCollection_default(geometries);
}
function readPointGeometry(object) {
  return new Point_default(object["coordinates"]);
}
function readLineStringGeometry(object) {
  return new LineString_default(object["coordinates"]);
}
function readMultiLineStringGeometry(object) {
  return new MultiLineString_default(object["coordinates"]);
}
function readMultiPointGeometry(object) {
  return new MultiPoint_default(object["coordinates"]);
}
function readMultiPolygonGeometry(object) {
  return new MultiPolygon_default(object["coordinates"]);
}
function readPolygonGeometry(object) {
  return new Polygon_default(object["coordinates"]);
}
function writeGeometry(geometry, opt_options) {
  geometry = transformGeometryWithOptions(geometry, true, opt_options);
  var type = geometry.getType();
  var geoJSON;
  switch (type) {
    case "Point": {
      geoJSON = writePointGeometry(
        geometry,
        opt_options
      );
      break;
    }
    case "LineString": {
      geoJSON = writeLineStringGeometry(
        geometry,
        opt_options
      );
      break;
    }
    case "Polygon": {
      geoJSON = writePolygonGeometry(
        geometry,
        opt_options
      );
      break;
    }
    case "MultiPoint": {
      geoJSON = writeMultiPointGeometry(
        geometry,
        opt_options
      );
      break;
    }
    case "MultiLineString": {
      geoJSON = writeMultiLineStringGeometry(
        geometry,
        opt_options
      );
      break;
    }
    case "MultiPolygon": {
      geoJSON = writeMultiPolygonGeometry(
        geometry,
        opt_options
      );
      break;
    }
    case "GeometryCollection": {
      geoJSON = writeGeometryCollectionGeometry(
        geometry,
        opt_options
      );
      break;
    }
    case "Circle": {
      geoJSON = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return geoJSON;
}
function writeGeometryCollectionGeometry(geometry, opt_options) {
  var geometries = geometry.getGeometriesArray().map(function(geometry2) {
    var options = assign({}, opt_options);
    delete options.featureProjection;
    return writeGeometry(geometry2, options);
  });
  return {
    type: "GeometryCollection",
    geometries
  };
}
function writeLineStringGeometry(geometry, opt_options) {
  return {
    type: "LineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiLineStringGeometry(geometry, opt_options) {
  return {
    type: "MultiLineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPointGeometry(geometry, opt_options) {
  return {
    type: "MultiPoint",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPolygonGeometry(geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return {
    type: "MultiPolygon",
    coordinates: geometry.getCoordinates(right)
  };
}
function writePointGeometry(geometry, opt_options) {
  return {
    type: "Point",
    coordinates: geometry.getCoordinates()
  };
}
function writePolygonGeometry(geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return {
    type: "Polygon",
    coordinates: geometry.getCoordinates(right)
  };
}
var GeoJSON_default = GeoJSON;

// dep:ol_format_GeoJSON
var ol_format_GeoJSON_default = GeoJSON_default;
export {
  ol_format_GeoJSON_default as default
};
//# sourceMappingURL=ol_format_GeoJSON.js.map
